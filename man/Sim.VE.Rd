% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_VE.R
\name{Sim.VE}
\alias{Sim.VE}
\alias{rmvn}
\title{Simulate eigenvalue dispersion indices}
\usage{
Sim.VE(
  b = 100L,
  X,
  V,
  cV = sqrtfun(V),
  N = nrow(X),
  divisor = c("UB", "ML"),
  m = switch(divisor, UB = N - 1, ML = N),
  center = TRUE,
  scale. = FALSE,
  sub = seq_len(ncol(cV)),
  nv = 0,
  sqrt_method = "chol",
  drop_0 = FALSE,
  tol = .Machine$double.eps * 100
)

rmvn(
  N,
  p = 2L,
  s2 = 1,
  V = s2 * diag(p),
  cV = sqrtfun(V),
  mean = rep_len(0, p),
  sqrt_method = "chol"
)
}
\arguments{
\item{b}{Number of iterations.}

\item{X}{(Optional) Data matrix; when \code{V} and \code{cV} are missing,
the sample covariance matrix from \code{X} is used as
the population covariance matrix in simulations (parametric bootstrapping).}

\item{V}{Population covariance matrix, assumed validly constructed;
by default a spherical covariance is used;
ignored when \code{cV} is provided.}

\item{cV}{Cholesky factor of \code{V}; this can be specified instead of \code{V}.
Potentially useful when multiple simulations are run for the same \code{V}
(although this will not substantially improve speed for a single call of
\code{Sim.VE(V = ...)}, where \code{sqrtfun(V)} is called only once).}

\item{N}{Sample size in each iteration or each run of \code{rmvn()}.}

\item{divisor, m, nv, drop_0, tol, center, scale., sub}{These arguments are passed to \code{VE()}.
\code{center} and \code{scale.} are also used construct \code{V}
when \code{X} is provided.}

\item{sqrt_method}{Method for matrix square root, which defines the internal function
\code{sqrtfun()}. Choose one from the following:
\code{"chol"} or \code{"default"} for \code{chol()},
\code{"chol_piv"} or \code{"pivot"} for \code{chol_piv()},
\code{"chol_qr"} or \code{"qr"} for \code{chol_qr()},
\code{"matsqrt"} or \code{"sqrt"} for \code{matsqrt()}.
See \link{sqrt_methods} for details. Ignored when \code{cV} is provided.}

\item{p}{Number of variables; ignored when \code{V} or \code{cV} is provided.}

\item{s2}{Population variance used for the spherical condition;
ignored when \code{V} or \code{cV} is provided.}

\item{mean}{Population mean vector; default is a \eqn{p} vector of 0's.}
}
\value{
\code{Sim.VE()} invisiblly returns a list containing the following:
\describe{
\item{VEv}{Eigenvalue variance of cov matrix V(S) (b vector)}
\item{VRv}{Relative eigenvalue variance of cov matrix Vrel(S) (b vector)}
\item{Lv}{Eigenvalues of cov matrix (p * b matrix)}
\item{VEr}{Eigenvalue variance of cor matrix V(R) (b vector)}
\item{VRr}{Relative eigenvalue variance of cor matrix Vrel(R) (b vector)}
\item{Lr}{Eigenvalues of cor matrix (p * b matrix)}
(the rest are returned only when \code{nv > 0})
\item{Uv}{Eigenvectors of cov matrix (p * nv * b array)}
\item{Ur}{Eigenvectors of cor matrix (p * nv * b array)}
\item{Uv.org}{Eigenvectors of population cov matrix (p * nv matrix)}
\item{Ur.org}{Eigenvectors of population cor matrix (p * nv matrix)}
(\code{Uv.org} and \code{Ur.org} are provided
as references for signs of eigenvectors)
}

\code{rmvn()} returns a \eqn{N * p} matrix with
the specified population mean and covariance.
}
\description{
\code{Sim.VE()} iteratively generates multivariate normal variates,
from which eigenvalues, eigenvectors (optional, if \code{nv > 0}),
and eigenvalue dispersion indices
(both unstandardized \eqn{V} and standardized \eqn{V_{rel}}) of
sample covariance and correlation matrices are obtained.
These are returned as an invisible list.

\code{rmvn()} is an internal function to generate
multivariate normal variates.
}
\details{
When \code{Sim.VE()} is called, either data (\code{X}),
a covariance matrix (\code{V}),
or its Cholesky factor (\code{cV}) should be given.
Specify the sample size \code{N} as well, unless \code{X} is provided.

\code{Sim.VE()} does not actually calculate sample covariance/correlation
matrices, but instead directly obtain eigenvalues and eigenvectors of these
from singular value decomposition \code{svd()} of normal variates
generated with \code{rmvn()}.

In the output of \code{Sim.VE()}, suffices \code{*v} and \code{*r}
denote covariance and correlation matrices, respectively.
}
\examples{
Lambda <- c(4, 2, 1, 1)
(Sigma <- GenCov(evalues = Lambda, evectors = "random"))
N <- 10
set.seed(35638)
X1 <- eigvaldisp:::rmvn(N = N, V = Sigma)
cSigma <- chol(Sigma)
set.seed(35638)
X2 <- eigvaldisp:::rmvn(N = N, cV = cSigma)
stopifnot(all.equal(X1, X2))
# These are identical. Providing cV is quicker as it skips sqrtfun(V),
# so this may be useful when multiple simulations are to be run with
# the same population covariance matrix.

# A small simulation
sim_result <- Sim.VE(b = 50L, V = Sigma, N = N)
str(sim_result)
# Results are returned as a list (see "Value" for details)

# Syntax for parametric bootstrapping
param_boot <- Sim.VE(b = 50L, X = X1)

}
\seealso{
\link{VE}, \link{sqrt_methods}
}
