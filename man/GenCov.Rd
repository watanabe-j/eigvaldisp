% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GenCov.R
\name{GenCov}
\alias{GenCov}
\title{Generate covariance matrix of known structure}
\usage{
GenCov(
  p = length(evalues),
  VR = 0.5,
  scale. = NULL,
  evalues = "auto",
  evectors = "plain",
  shape = c("q-large", "elongate", "linearly_decreasing", "quadratically_decreasing"),
  q = 1,
  random_rotation = TRUE,
  which_rotate = c("random", "head", "tail", "minmax"),
  tol = 1e-12,
  maxiter = 5000L,
  seed = NULL,
  check = any(evalues == 0)
)
}
\arguments{
\item{p}{Number of variables.}

\item{VR}{The relative eigenvalue variance of the generated matrix;
used only when \code{shape = "q-large"} or \code{"elongated"}.}

\item{scale.}{When provided, the outcome is proportionally scaled
to have the trace equal to this value.}

\item{evalues}{Numeric vector of eigenvalues. If missing, eigenvalues are automatically
generated according to \code{p}, \code{VR}, \code{shape}, and \code{q}.}

\item{evectors}{Option to specify how eigenvectors are generated:
\describe{
\item{"plain"}{Eigenvectors are taken as the identity matrix of
order \eqn{p}.}
\item{"random"}{Random eigenvectors are generated by QR decomposition of
a square matrix of standard normal variates; i.e., sampling from
the Haar invariant distribution (ignoring the signs of diagonals).}
\item{"MAP"}{Eigenvectors are constructed so that the resultant matrix
is a correlation matrix with the specified eigenvalues
(scaled so that the trace equals \eqn{p}); based on the iterative
algorithm of Waller (2020). Modified from \code{fungible::rMAP()}.}
\item{"Givens"}{Similar to \code{"MAP"}, but with an algorithm adopted
from Davies & Higham (2000) with modifications;
this is much faster and is guaranteed to converge.}
}
Alternatively, a matrix of eigenvectors can be provided to specify
full or partial eigenvectors for the outcome matrix.
These are converted to be orthonormal;
randomly generated vectors are appended as necessary.
Remember the ambiguity of eigenvectors' polarities (sign-swapping).}

\item{shape}{Option to specify the "shape" of the covariance matrix;
ignored when \code{evalues} is provided.  Options allowed are:
\describe{
\item{"q-large"}{The \eqn{q} leading eigenvalues equally large,
the rest \eqn{p - q} equally small}
\item{"elongate"}{Special case of \code{q-large} with \code{q = 1}}
\item{"linearly_decreasing"}{Eigenvalues linearly decreasing
in magnitude}
\item{"quadratically_decreasing"}{Eigenvalues quadratically decreasing}
}
User-specified \code{VR} is ignored in the last two options.
The terminology follows Watanabe (2022).}

\item{q}{The number of large eigenvalues. To be used with \code{shape = q-large}.}

\item{random_rotation}{Only relevant when \code{evectors = "Givens"};
logical to specify whether the initial diagonal matrix of eigenvalues
is randomly rotated or not. For reproducibility in simulation studies.}

\item{which_rotate}{When \code{evectors = "Givens"}, specify which (or in what order)
columns/rows are subject to Givens rotation:
\describe{
\item{"random"}{Columns/rows are chosen in random order.
This conforms with the original algorithm of Davies & Higham (2020).}
\item{"head"/"tail"}{The first/last ones among candidates are rotated.
For reproducibility in simulation studies.}
\item{"minmax"}{Columns/rows corresponding to a minimum and maximum
of the diagonal elements are rotated. This is slightly faster but
presumably produces strong, isolated correlations.}
}}

\item{tol}{Only relevant when \code{evectors = "MAP"}; numeric to specify the
tolerance against which convergence of eigenvectors is evaluated.}

\item{maxiter}{Only relevant when \code{evectors = "MAP"}; maximum number of iterations.}

\item{seed}{Random seed passed to \code{set.seed(seed)}
before random eigenvectors are generated.}

\item{check}{Logical, whether to check and ensure all eigenvalues of the
resultant matrix are nonnegative. By default, automatically turned on
when any of the specified/generated eigenvalues are equal to 0.}
}
\value{
A \eqn{p * p} numeric matrix with the specified eigenstructure
}
\description{
This function generates a (population) covariance/correlation matrix with
known eigenstructure, which is specified by the number of variables \code{p},
\code{shape}, and (when applicable) relative eigenvalue variance \code{VR}.
Eigenvector matrix can be the identity matrix, a random orthonormal matrix,
or constructed to yield a correlation matrix
(when \code{evectors = "MAP"} or \code{"Givens"}).
Alternatively, eigenvalues \code{evalues} and eigenvectors \code{evectors}
can directly be specified.
}
\details{
Either \code{p} or \code{evalues} should be specified.
A straightforward use is to provide a numeric vector of eigenvalues
with the argument \code{evalues}. If this argument is missing,
then eigenvalues are generated according to \code{p},
\code{VR}, \code{shape}, and \code{q}.
When \code{shape = "q-large"}, the first \eqn{q} eigenvalues are set
equally large, with the rest \eqn{p - q} equally small.
Specifically, the larger ones are
\eqn{1 + sqrt(VR) * sqrt((p - 1) * (p - q) / q)} and the smaller ones are
\eqn{1 - sqrt(VR) * sqrt(q * (p - 1) / (p - q))}.
The combination of \code{p}, \code{q}, and \code{VR} should be such that
all resultant eigenvalues are nonnegative; an error is returned otherwise.
Alternatively, gradually decreasing eigenvalues can be generated with
\code{shape = "linearly_decreasing"} or \code{"quadratically_decreasing"}.
See Watanabe (2022) for technical details.

Unless \code{evalues} is specified, the trace of the resultant matrix
equals to \eqn{p} by default. The argument \code{scale.} can be used to
\strong{force} scale the overall matrix, so that the trace equals this value.
This scaling is applied just before the outcome is returned, so
will not preserve absolute magnitudes of \code{evalues} even when
this is specified (relative magnitudes are preserved).

A correlation matrix with known eigenvalues can be generated by
choosing \code{evectors = "MAP"} or \code{"Givens"}.
These will construct an appropriate eigenvector matrix so that the outcome
is a correlation matrix (Davies & Higham, 2000; Waller, 2020).
User-specified eigenvalues are scaled to sum to \eqn{p} in these cases.
Note that, when \code{scale.} is specified as well, the outcome will be
a matrix proportional to a correlation matrix
(i.e., not a correlation matrix unless \code{scale. == p}).

The original algorithm of Davies & Higham (2020) involves a random choice
between two possible rotation angles, but this randomness is omitted
(the angle with the larger tangent is always chosen) in
the present implementation in favor of speed and reproducibility.
As such, the present implementation of \code{"Givens"} slightly deviates
from the original algorithm.

\emph{Copyright notice}: The \code{"MAP"} algorithm originally derived
from \code{rMAP()} of the package
\code{fungible} version 1.99 (Waller, 2021), which is under GPL (>= 2).
(Strictly speaking, this was first adopted from the supplemental material
of Waller [2020], which is licensed under CC-BY-4.0.)
The adopted block is indicated in the source code.
The \code{"Givens"} algorithm used to be adopted from
\code{fungible::rGivens()} in an earlier version of this package,
but has essentially been rewritten by the present author
based on Davies & Higham (2000) with modifications.
}
\examples{
# Covariance matrix with no covariance (identity matrix)
GenCov(4, 0)

# Relative eigenvalue variance = 0.25, with 1 and 2 large eigenvalues
GenCov(4, 0.5 ^ 2)
GenCov(4, 0.5 ^ 2, q = 2)

# Relative eigenvalue variance = 0.25, with 1 and 2 large eigenvalues
GenCov(evalues = c(3, 2, 1, 1))

# Linearly decreasing eigenvalues; VR, q, and evalues are ignored
GenCov(4, shape = "linearly_decreasing")

# With random orthonormal eigenvector matrix
GenCov(4, 0.5 ^ 2, evectors = "random")

# With user-specified (partial) eigenvector matrix
GenCov(4, 0.5 ^ 2, evectors = rep.int(1 / sqrt(4), 4))

# Correlation matrix with two different algorithms
GenCov(4, 0.5 ^ 2, q = 2, evectors = "MAP")
GenCov(4, 0.5 ^ 2, q = 2, evectors = "Givens")

# Note that, by default, results of the above algorithms usually involve
# random fluctuation. To eliminate this, use either:
GenCov(4, 0.5 ^ 2, q = 2, evectors = "Givens", random_rotation = FALSE)
                              # Optionally with which_rotate = "head"/"tail"
GenCov(4, 0.5 ^ 2, q = 2, evectors = "Givens", seed = 1234)
                              # Arbitrary random seed
# The first way is not available for "MAP", but the second one is.

}
\references{
Davies, P. I. & Higham, N. J. (2000) Numerically stable generation of
correlation matrices and their factors.
\emph{BIT Numerical Mathematics} \strong{40}, 640--651.
doi:\href{https://doi.org/10.1023/A:1022384216930}{10.1023/A:1022384216930}.

Waller, N. G. (2020). Generating correlation matrices with specified
eigenvalues using the method of alternating projections.
\emph{American Statistician} \strong{74}, 21--28.
doi:\href{https://doi.org/10.1080/00031305.2017.1401960}{10.1080/00031305.2017.1401960}.

Waller, N. G. (2021). fungible: psychometric functions from the Waller Lab.
R package version 1.99.
\url{https://CRAN.R-project.org/package=fungible}.

Watanabe, J. (2022). Statistics of eigenvalue dispersion indices:
quantifying the magnitude of phenotypic integration. \emph{Evolution},
\strong{76}, 4--28. doi:\href{https://doi.org/10.1111/evo.14382}{10.1111/evo.14382}.
}
